<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimConnectRequestTracker: SimConnectRequestTracker Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SimConnectRequestTracker
   </div>
   <div id="projectbrief">SimConnectRequestTracker provides methods for recording and retrieving data associated with SimConnect function calls.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_sim_connect_request_tracker.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_sim_connect_request_tracker-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SimConnectRequestTracker Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code><a class="el" href="class_sim_connect_request_tracker.html" title="SimConnectRequestTracker provides methods for recording and retrieving data associated with SimConnec...">SimConnectRequestTracker</a></code> provides methods for recording and retrieving data associated with SimConnect function calls.  
 <a href="class_sim_connect_request_tracker.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_sim_connect_request_tracker_8h_source.html">SimConnectRequestTracker.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sim_connect_request_tracker_1_1_request_data.html">RequestData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SimConnect request (method invocation) tracking record for storing which request caused a simulator error (such as unknown variable/event name, etc).  <a href="struct_sim_connect_request_tracker_1_1_request_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afbc5febed03520a73d356d348523cfa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#afbc5febed03520a73d356d348523cfa6">SimConnectRequestTracker</a> (uint32_t maxRecords=250)</td></tr>
<tr class="memdesc:afbc5febed03520a73d356d348523cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an instance of the tracker. Typically only one global/static instance should track all requests, but this is not required (each tracker instance keeps its own log of requests, they are not shared between instances).  <a href="class_sim_connect_request_tracker.html#afbc5febed03520a73d356d348523cfa6">More...</a><br /></td></tr>
<tr class="separator:afbc5febed03520a73d356d348523cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4249e85a58d467103f63b4b1271f94a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#af4249e85a58d467103f63b4b1271f94a">setMaxRecords</a> (uint32_t maxRecords)</td></tr>
<tr class="memdesc:af4249e85a58d467103f63b4b1271f94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the maximum number of request records stored in the cache. See description of the <code>maxRecords</code> argument in <code><a class="el" href="class_sim_connect_request_tracker.html#afbc5febed03520a73d356d348523cfa6" title="Construct an instance of the tracker. Typically only one global/static instance should track all requ...">SimConnectRequestTracker()</a></code> constructor for details. If this value is reduced from the original (starting) value, all records stored at indexes past the new maximum will be deleted, which may include the most recent records (they are stored in a round-robin fashion so the current "write slot" may by anywhere in the cache at any given moment).  <a href="class_sim_connect_request_tracker.html#af4249e85a58d467103f63b4b1271f94a">More...</a><br /></td></tr>
<tr class="separator:af4249e85a58d467103f63b4b1271f94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dff3cfb516f13bd3c4af75df1386853"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7dff3cfb516f13bd3c4af75df1386853"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#a7dff3cfb516f13bd3c4af75df1386853">addRequestRecord</a> (HANDLE hSim, std::string &amp;&amp;methodInfo, Args... args)</td></tr>
<tr class="memdesc:a7dff3cfb516f13bd3c4af75df1386853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a record of a SimConnect request. Needs a handle to SimConnect to get the last sent ID, which it saves along with the passed SimConnect function name and any number of arguments which were originally passed to whatever SimConnect function was called. If needed, the record can later be checked using the <code>dwSendId</code> from SimConnect's exception message and the original call which caused the exception can be logged.  <a href="class_sim_connect_request_tracker.html#a7dff3cfb516f13bd3c4af75df1386853">More...</a><br /></td></tr>
<tr class="separator:a7dff3cfb516f13bd3c4af75df1386853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54be1bc74f3736098da3b1b80732d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sim_connect_request_tracker_1_1_request_data.html">RequestData</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#afc54be1bc74f3736098da3b1b80732d0">getRequestRecord</a> (uint32_t dwSendId, uint32_t ex=SIMCONNECT_EXCEPTION_NONE, uint32_t idx=0)</td></tr>
<tr class="memdesc:afc54be1bc74f3736098da3b1b80732d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find and return a request record for the given dwSendId. If no record is found or the cache is disabled entirely, then it returns a reference to a static instance (which has no method or argument details) populated with the given <code>dwSendID</code>, <code>ex</code>, and <code>idx</code> parameters.  <a href="class_sim_connect_request_tracker.html#afc54be1bc74f3736098da3b1b80732d0">More...</a><br /></td></tr>
<tr class="separator:afc54be1bc74f3736098da3b1b80732d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a07d97f8294bdac74bcf1ccf0ff968ad3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a07d97f8294bdac74bcf1ccf0ff968ad3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#a07d97f8294bdac74bcf1ccf0ff968ad3">streamArgs</a> (std::ostream &amp;os, T var1, Args... var2)</td></tr>
<tr class="memdesc:a07d97f8294bdac74bcf1ccf0ff968ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively output all arguments to a stream, with comma separator between each (no spaces). Args types must have stream operators, obviously.  <a href="class_sim_connect_request_tracker.html#a07d97f8294bdac74bcf1ccf0ff968ad3">More...</a><br /></td></tr>
<tr class="separator:a07d97f8294bdac74bcf1ccf0ff968ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb20aaacfee24e6118e7d60d4ffe898c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:adb20aaacfee24e6118e7d60d4ffe898c"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#adb20aaacfee24e6118e7d60d4ffe898c">printArgs</a> (Args... args)</td></tr>
<tr class="memdesc:adb20aaacfee24e6118e7d60d4ffe898c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs all arguments to a string with comma separators. Args types must have stream operators (uses <code><a class="el" href="class_sim_connect_request_tracker.html#a07d97f8294bdac74bcf1ccf0ff968ad3" title="Recursively output all arguments to a stream, with comma separator between each (no spaces)....">streamArgs()</a></code> to create a string).  <a href="class_sim_connect_request_tracker.html#adb20aaacfee24e6118e7d60d4ffe898c">More...</a><br /></td></tr>
<tr class="separator:adb20aaacfee24e6118e7d60d4ffe898c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d52985d23977ee470d9f190af39828"><td class="memItemLeft" align="right" valign="top">static const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sim_connect_request_tracker.html#a24d52985d23977ee470d9f190af39828">exceptionName</a> (uint32_t id)</td></tr>
<tr class="memdesc:a24d52985d23977ee470d9f190af39828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get SimConnect exception name (enum as string) from ID enum. Omits the "SIMCONNECT_EXCEPTION" part.  <a href="class_sim_connect_request_tracker.html#a24d52985d23977ee470d9f190af39828">More...</a><br /></td></tr>
<tr class="separator:a24d52985d23977ee470d9f190af39828"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p ><code><a class="el" href="class_sim_connect_request_tracker.html" title="SimConnectRequestTracker provides methods for recording and retrieving data associated with SimConnec...">SimConnectRequestTracker</a></code> provides methods for recording and retrieving data associated with SimConnect function calls. </p>
<p >When SimConnect sends an exception message (<code>SIMCONNECT_RECV_ID_EXCEPTION</code>), it only provides a "send ID" with which to identify what caused the exception in the first place. Since requests are asynchronous, there needs to be some way to record what the original function call was in order to find out what the exception is referring to.</p>
<p >Two primary methods are provided to achieve this goal: <code><a class="el" href="class_sim_connect_request_tracker.html#a7dff3cfb516f13bd3c4af75df1386853" title="Makes a record of a SimConnect request. Needs a handle to SimConnect to get the last sent ID,...">addRequestRecord()</a></code> and <code><a class="el" href="class_sim_connect_request_tracker.html#afc54be1bc74f3736098da3b1b80732d0" title="Try to find and return a request record for the given dwSendId. If no record is found or the cache is...">getRequestRecord()</a></code> which should be fairly self-explanatory. The former is called right after a SimConnect function is invoked and gets the unique "send ID" from SimConnect and saved all data in a cache.<br  />
Use the latter method to find which SimConnect function call caused an exception in the <code>SIMCONNECT_RECV_ID_EXCEPTION</code> handler of your message dispatcher. See the respective documentation for further details on each method.</p>
<p >Request data is available as a <code><a class="el" href="struct_sim_connect_request_tracker_1_1_request_data.html" title="SimConnect request (method invocation) tracking record for storing which request caused a simulator e...">RequestData</a></code> structure, which contains all relevant information about the original function call (method name and arguments list), and also provides convenient output methods like an <code>ostream &lt;&lt;</code> operator and a <code>RequestData::toString()</code>. Both will show as much data as possible, including the exception name and at which argument the error occurred (the <code>dwIndex</code>).</p>
<p >Request data is stored in a "circular buffer" type cache with a configurable maximum number of records stored. After the maximum is reached, records start to be overwritten, starting at the oldest. The amount of memory used for the requests cache can be controlled either in the constructor <code>maxRecords</code> argument or using the <code><a class="el" href="class_sim_connect_request_tracker.html#af4249e85a58d467103f63b4b1271f94a" title="Sets the maximum number of request records stored in the cache. See description of the maxRecords arg...">setMaxRecords()</a></code> method. This memory is pre-allocated on the stack, and each record takes 440B of stack space. Additional heap (de)allocations will happen at runtime by the <code>string</code> and <code>stringstream</code> type members of <code><a class="el" href="struct_sim_connect_request_tracker_1_1_request_data.html" title="SimConnect request (method invocation) tracking record for storing which request caused a simulator e...">RequestData</a></code> as they are created/destroyed dynamically. See docs on <code><a class="el" href="class_sim_connect_request_tracker.html#afbc5febed03520a73d356d348523cfa6" title="Construct an instance of the tracker. Typically only one global/static instance should track all requ...">SimConnectRequestTracker()</a></code> c'tor and <code><a class="el" href="class_sim_connect_request_tracker.html#af4249e85a58d467103f63b4b1271f94a" title="Sets the maximum number of request records stored in the cache. See description of the maxRecords arg...">setMaxRecords()</a></code> for some more details.</p>
<p >A few convenience methods are also provided for when a request is not tracked (or the record of it wasn't found in cache) or for other logging purposes. A SimConnect exception name can be looked up based on the <code>dwException</code> enum value from the exception message struct using the static <code><a class="el" href="class_sim_connect_request_tracker.html#a24d52985d23977ee470d9f190af39828" title="Get SimConnect exception name (enum as string) from ID enum. Omits the &quot;SIMCONNECT_EXCEPTION&quot; part.">exceptionName()</a></code> method.<br  />
A variadic template is also provided for logging any number of argument values to a stream or string, for example to log a returned error right after a SimConnect function call.</p>
<p >All methods in this class are thread-safe if the <code>SCRT_THREADSAFE</code> macro == 1, which is the default unless <code>_LIBCPP_HAS_NO_THREADS</code> is defined.</p>
<h2><a class="anchor" id="autotoc_md0"></a>
Examples</h2>
<p >Assuming that: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_sim_connect_request_tracker.html">SimConnectRequestTracker</a> g_requestTracker {};</div>
<div class="line">HANDLE hSim;  <span class="comment">// handle to an open SimConnect</span></div>
<div class="line"><span class="comment">// some data fields used in the example SimConnect function calls</span></div>
<div class="line">SIMCONNECT_CLIENT_DATA_DEFINITION_ID cddId;</div>
<div class="line">DWORD szOrType;</div>
<div class="line"><span class="keywordtype">float</span> epsilon;</div>
<div class="line">DWORD offset;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Signature of SimConnect function used in the examples, for reference:</span></div>
<div class="line"><span class="comment">// SimConnect_AddToClientDataDefinition(HANDLE hSimConnect,</span></div>
<div class="line"><span class="comment">//    SIMCONNECT_CLIENT_DATA_DEFINITION_ID DefineID,</span></div>
<div class="line"><span class="comment">//    DWORD dwOffset,</span></div>
<div class="line"><span class="comment">//    DWORD dwSizeOrType,</span></div>
<div class="line"><span class="comment">//    float fEpsilon = 0,</span></div>
<div class="line"><span class="comment">//    DWORD DatumID = SIMCONNECT_UNUSED</span></div>
<div class="line"><span class="comment">// )</span></div>
<div class="ttc" id="aclass_sim_connect_request_tracker_html"><div class="ttname"><a href="class_sim_connect_request_tracker.html">SimConnectRequestTracker</a></div><div class="ttdoc">SimConnectRequestTracker provides methods for recording and retrieving data associated with SimConnec...</div><div class="ttdef"><b>Definition:</b> SimConnectRequestTracker.h:168</div></div>
</div><!-- fragment --><p >Basic usage: </p><div class="fragment"><div class="line"><span class="comment">// Make a SimConnect function call somewhere in your code and save the request record.</span></div>
<div class="line">HRESULT hr = SimConnect_AddToClientDataDefinition(hSim, cddId, offset, szOrType, epsilon);</div>
<div class="line"><span class="keywordflow">if</span> FAILED(hr)</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;SimConnect_AddToClientDataDefinition(&quot;</span>  &lt;&lt; cddId &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; szOrType &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; offset &lt;&lt; <span class="charliteral">&#39;,&#39;</span> &lt;&lt; epsilon &lt;&lt; <span class="stringliteral">&quot;) failed with &quot;</span> &lt;&lt; hr &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  g_requestTracker.addRequestRecord(hSim, <span class="stringliteral">&quot;SimConnect_AddToClientDataDefinition&quot;</span>, cddId, szOrType, offset, epsilon);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="comment">// In your SimConnect message dispatch handler you can then retrieve the saved function call if a `SIMCONNECT_RECV_ID_EXCEPTION` type message is received.</span></div>
<div class="line"><span class="keywordtype">void</span> simConnectMessageDispatch(SIMCONNECT_RECV *pData, DWORD cbData) {</div>
<div class="line">  <span class="keywordflow">switch</span> (pData-&gt;dwID) {</div>
<div class="line">    <span class="comment">// ...  other handlers</span></div>
<div class="line">    <span class="keywordflow">case</span> SIMCONNECT_RECV_ID_EXCEPTION:</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;SimConnect exception: &quot;</span> &lt;&lt; g_requestTracker-&gt;getRequestRecord(pData-&gt;dwSendID, pData-&gt;dwException, pData-&gt;dwIndex);</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >This next example shows how to set up a "proxy" template which will call any SimConnect function passed to it, using any number of arguments, log any immediate error or add a tracking record, and return the <code>HRESULT</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Main SimConnect function invoker template which does the actual call, logs any error or creates a request record, and returns the HRESULT from SimConnect.</span></div>
<div class="line"><span class="comment">// The first argument, `fname`, is the function name that is being called, as a string, for logging purposes. It can be any string actually, perhaps a full function signature.</span></div>
<div class="line"><span class="comment">// The other arguments are a pointer to the function, a handle to SimConnect, and any further arguments passed along to SimConnect in the function call.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">static</span> HRESULT simConnectProxy(<span class="keyword">const</span> <span class="keywordtype">char</span> *fname, std::function&lt;HRESULT(HANDLE, Args...)&gt; f, HANDLE hSim, Args... args) {</div>
<div class="line">  <span class="keyword">const</span> HRESULT hr = std::bind(f, std::forward&lt;HANDLE&gt;(hSim), std::forward&lt;Args&gt;(args)...)();</div>
<div class="line">  <span class="keywordflow">if</span> FAILED(hr)</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; fname &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; <a class="code hl_function" href="class_sim_connect_request_tracker.html#adb20aaacfee24e6118e7d60d4ffe898c">SimConnectRequestTracker::printArgs</a>(args...) &lt;&lt; <span class="stringliteral">&quot;) failed with &quot;</span> &lt;&lt; hr &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    simRequestTracker().addRequestRecord(hSim, fname, args...);</div>
<div class="line">  <span class="keywordflow">return</span> hr;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Because we really want type deduction, we can invoke simConnectProxy() via this template w/out specifying each argument type for the `simConnectProxy&lt;&gt;()` call.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line"><span class="keyword">static</span> HRESULT invokeSimConnect(<span class="keyword">const</span> <span class="keywordtype">char</span> *fname, HRESULT(*f)(HANDLE, Args...), HANDLE hSim, Args... args) {</div>
<div class="line">  <span class="keywordflow">return</span> simConnectProxy(fname, std::function&lt;HRESULT(HANDLE, Args...)&gt;(f), hSim, args...);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The macro allows us to only pass the function name once to get both the name string and the actual callable. Optional.</span></div>
<div class="line"><span class="preprocessor">#define INVOKE_SIMCONNECT(F, ...)  invokeSimConnect(#F, &amp;F, __VA_ARGS__)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... then use the macro to make the call, or if you don&#39;t like macros, or want to use a specific function name (perhaps with signature), specify the name of the function yourself.</span></div>
<div class="line"><span class="comment">// **Note** that unless you&#39;re using c++20 (or higher), for the template function type deduction to work, the arguments list and types need to match the SimConnect function signature _exactly_.</span></div>
<div class="line"><span class="comment">// Including any optional arguments (the last 2 in this example).  C++20 apparently improves the deduction rules but I haven&#39;t personally tested it.</span></div>
<div class="line">INVOKE_SIMCONNECT(SimConnect_AddToClientDataDefinition, hSim, cddId, offset, szOrType, epsilon, SIMCONNECT_UNUSED);</div>
<div class="line"><span class="comment">// invokeSimConnect(&quot;AddToClientDataDefinition(DefineID, dwOffset, dwSizeOrType, fEpsilon, DatumID)&quot;, &amp;SimConnect_AddToClientDataDefinition, hSim, cddId, offset, szOrType, epsilon, SIMCONNECT_UNUSED);</span></div>
<div class="ttc" id="aclass_sim_connect_request_tracker_html_adb20aaacfee24e6118e7d60d4ffe898c"><div class="ttname"><a href="class_sim_connect_request_tracker.html#adb20aaacfee24e6118e7d60d4ffe898c">SimConnectRequestTracker::printArgs</a></div><div class="ttdeci">static std::string printArgs(Args... args)</div><div class="ttdoc">Outputs all arguments to a string with comma separators. Args types must have stream operators (uses ...</div><div class="ttdef"><b>Definition:</b> SimConnectRequestTracker.h:316</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afbc5febed03520a73d356d348523cfa6" name="afbc5febed03520a73d356d348523cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc5febed03520a73d356d348523cfa6">&#9670;&nbsp;</a></span>SimConnectRequestTracker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SimConnectRequestTracker::SimConnectRequestTracker </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxRecords</em> = <code>250</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an instance of the tracker. Typically only one global/static instance should track all requests, but this is not required (each tracker instance keeps its own log of requests, they are not shared between instances). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxRecords</td><td>The maximum number of request records to store in the cache. If many requests are made in fast succession (like at the startup of a SimConnect client requesting a lot of data value subscriptions), some records may get lost (overwritten) by the time SimConnect manages to send an exception message. On the other hand for low volume usage, memory can be saved by reducing the number of stored records. This property can also be changed during runtime using <code><a class="el" href="class_sim_connect_request_tracker.html#af4249e85a58d467103f63b4b1271f94a" title="Sets the maximum number of request records stored in the cache. See description of the maxRecords arg...">setMaxRecords()</a></code> method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7dff3cfb516f13bd3c4af75df1386853" name="a7dff3cfb516f13bd3c4af75df1386853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dff3cfb516f13bd3c4af75df1386853">&#9670;&nbsp;</a></span>addRequestRecord()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimConnectRequestTracker::addRequestRecord </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>hSim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>methodInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a record of a SimConnect request. Needs a handle to SimConnect to get the last sent ID, which it saves along with the passed SimConnect function name and any number of arguments which were originally passed to whatever SimConnect function was called. If needed, the record can later be checked using the <code>dwSendId</code> from SimConnect's exception message and the original call which caused the exception can be logged. </p>

</div>
</div>
<a id="a24d52985d23977ee470d9f190af39828" name="a24d52985d23977ee470d9f190af39828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d52985d23977ee470d9f190af39828">&#9670;&nbsp;</a></span>exceptionName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char *const SimConnectRequestTracker::exceptionName </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get SimConnect exception name (enum as string) from ID enum. Omits the "SIMCONNECT_EXCEPTION" part. </p>

</div>
</div>
<a id="afc54be1bc74f3736098da3b1b80732d0" name="afc54be1bc74f3736098da3b1b80732d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54be1bc74f3736098da3b1b80732d0">&#9670;&nbsp;</a></span>getRequestRecord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sim_connect_request_tracker_1_1_request_data.html">RequestData</a> const  &amp; SimConnectRequestTracker::getRequestRecord </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dwSendId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ex</em> = <code>SIMCONNECT_EXCEPTION_NONE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idx</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find and return a request record for the given dwSendId. If no record is found or the cache is disabled entirely, then it returns a reference to a static instance (which has no method or argument details) populated with the given <code>dwSendID</code>, <code>ex</code>, and <code>idx</code> parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dwSendId</td><td>The <code>dwSendId</code> to look up, typically from the <code>SIMCONNECT_RECV_EXCEPTION.dwSendId</code> struct member. </td></tr>
    <tr><td class="paramname">ex</td><td>SimeConnect exception ID, typically from the <code>SIMCONNECT_RECV_EXCEPTION.dwException</code> member. This is stored in the returned RequestRecord, and is resolved to a string name (with <code><a class="el" href="class_sim_connect_request_tracker.html#a24d52985d23977ee470d9f190af39828" title="Get SimConnect exception name (enum as string) from ID enum. Omits the &quot;SIMCONNECT_EXCEPTION&quot; part.">exceptionName()</a></code>) for display with the <code>RequestData.toString()</code> or stream operator methods. </td></tr>
    <tr><td class="paramname">idx</td><td>SimeConnect exception parameter index, typically from the <code>SIMCONNECT_RECV_EXCEPTION.dwIndex</code> member. This is stored in the returned RequestRecord and is displayed in the <code>RequestData.toString()</code> or stream operator method outputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned reference should stay in scope unless the cache is shrunk (and that index gets deleted). However the data could change at any point if the cache storage slot is reused for a new request. Or, in the cases where a reference to a static instance is returned, the next <code><a class="el" href="class_sim_connect_request_tracker.html#afc54be1bc74f3736098da3b1b80732d0" title="Try to find and return a request record for the given dwSendId. If no record is found or the cache is...">getRequestRecord()</a></code> call will overwrite the static data from the previous call. All this to say: <b>do not store the reference.</b> </dd></dl>

</div>
</div>
<a id="adb20aaacfee24e6118e7d60d4ffe898c" name="adb20aaacfee24e6118e7d60d4ffe898c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb20aaacfee24e6118e7d60d4ffe898c">&#9670;&nbsp;</a></span>printArgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string SimConnectRequestTracker::printArgs </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs all arguments to a string with comma separators. Args types must have stream operators (uses <code><a class="el" href="class_sim_connect_request_tracker.html#a07d97f8294bdac74bcf1ccf0ff968ad3" title="Recursively output all arguments to a stream, with comma separator between each (no spaces)....">streamArgs()</a></code> to create a string). </p>

</div>
</div>
<a id="af4249e85a58d467103f63b4b1271f94a" name="af4249e85a58d467103f63b4b1271f94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4249e85a58d467103f63b4b1271f94a">&#9670;&nbsp;</a></span>setMaxRecords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SimConnectRequestTracker::setMaxRecords </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxRecords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the maximum number of request records stored in the cache. See description of the <code>maxRecords</code> argument in <code><a class="el" href="class_sim_connect_request_tracker.html#afbc5febed03520a73d356d348523cfa6" title="Construct an instance of the tracker. Typically only one global/static instance should track all requ...">SimConnectRequestTracker()</a></code> constructor for details. If this value is reduced from the original (starting) value, all records stored at indexes past the new maximum will be deleted, which may include the most recent records (they are stored in a round-robin fashion so the current "write slot" may by anywhere in the cache at any given moment). </p>

</div>
</div>
<a id="a07d97f8294bdac74bcf1ccf0ff968ad3" name="a07d97f8294bdac74bcf1ccf0ff968ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d97f8294bdac74bcf1ccf0ff968ad3">&#9670;&nbsp;</a></span>streamArgs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void SimConnectRequestTracker::streamArgs </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>var1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>var2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively output all arguments to a stream, with comma separator between each (no spaces). Args types must have stream operators, obviously. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_sim_connect_request_tracker_8h_source.html">SimConnectRequestTracker.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_sim_connect_request_tracker.html">SimConnectRequestTracker</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
